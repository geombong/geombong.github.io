[ { "title": "(일일회고)22.07.20", "url": "/posts/(%EC%9D%BC%EC%9D%BC%ED%9A%8C%EA%B3%A0)22.07.20/", "categories": "일일회고", "tags": "일일회고", "date": "2022-07-20 23:55:00 +0900", "snippet": "일일회고👨‍💻오늘 한일 Unit Test 공부 issue-tracker 프로젝트 Label, Assignee CRUD API 개발 Label Service Test 😆좋았던 점 Unit Test 공부를 하면서, 그동안 해야하지 라고 생각만 했던 테스트 진행을 할 수 있어 좋았다. 새로운걸 배우는건 늘 신기하고 재미있다. 🥺아쉬운 점 알고리즘 난 왜이렇게 어려운걸까 하기 싫어도 매일 한 문제 이상은 풀어보자.👨‍💻내일 할 일 issue-tracker 프로젝트 Label Service 제외한 나머지 Test 작성 로그인 한 유저에 대한 데이터만 해당 유저가 접근이 가능하도록 변경 알고리즘 1문제" }, { "title": "(TIL)UnitTest", "url": "/posts/(TIL)22.07.20/", "categories": "TIL", "tags": "TIL", "date": "2022-07-20 23:21:00 +0900", "snippet": "UnitTest JUnit5, assertj-core 3.x 버전 기준Mockito@Mock mock 모의 객체 생성을 위한 어노테이션@InjectMocks 주입을 수행해야 하는 필드를 표시하기 위한 어노테이션@ExtendWith(MockitoExtension.class) @ExtendWith: JUnit4에서 사용되던 @RunWith 를 대체하는 어노테이션, 테스트 확장을 위한 class 선언에 사용된다. MockitoExtension.class: @Mock 어노테이션으로 모의 객체를 생성하기 위해 선언 MockitoExtension.class BDDMockito학습 내용 BDD(Behavior-Driven Development) : 행위 주도 개발, 테스트 대상의 상태의 변화를 테스트 하는것이며 시나리오를 기반으로 테스트하는 패턴을 권장한다. 권장하는 기본 패턴은 given-when-then 구조를 가진다. Mockito 를 상속한 클래스(public class BDDMockito extends Mockito) given: 특정 상태에서 출발하여 when: 어떤 상태 변화를 가했을 때 then: 기대하는 상태로 완료되어야 한다.@Testvoid given_when_then() throws Exception { //given Long articleId = 1L; ArticleComment expected = createArticleComment(&quot;content&quot;); given(articleCommentRepository.findByArticle_Id(articleId)).willReturn(List.of(expected)); //when Page&amp;lt;ArticleCommentDto&amp;gt; actual = sut.searchArticleComment(articleId); //then assertThat(actual) .hasSize(1) .first() .hasFieldOrPropertyWithValue(&quot;content&quot;, expected.getContent()); then(articleCommentRepository).should().findByArticle_Id(articleId);} 게시글 Id로 게시글에 작성되어있는 댓글 리스트를 반환하는 간단한 테스트 예제 given: 1L 의 아이디를 가지는 게시글에 댓글 이 작성 되어 있는 상태를 만들고, 댓글 리포지토리에서 해당 게시글 아이디를 가지고 댓글을 찾은 상태에서 출발 when: searchArticleComment() 해당 메서드로 게시글 아이디에 해당하는 댓글을 찾았을때 then: content 라는 내용을 가지는 댓글이 반환되어야 한다. hasFieldOrPropertyWithValue : 실제 개체가 지정된 값을 가진 지정된 필드 또는 속성을 가지고 있는지 확인(content 라는 값을 가진 Object 가 있는지 확인) hasFieldOrPropertyWithValue Guide then(articleCommentRepository).should().findByArticle_Id(articleId) : 댓글 리포지토리에서 findByarticle_Id() 라는 매서드가 동작 해야한다. 주의할 점 Mockito Strict Stubbing and The UnnecessaryStubbingException@DisplayName(&quot;레이블 정보를 입력하면, 해당 레이블을 수정한다.&quot;)@Testvoid givenLabelInfo_whenUpdatingLabel_thenUpdatedLabel() throws Exception { //given Long labelId = 1L; String oldTitle = &quot;labelTitle1&quot;; String updateTitle = &quot;labelTitle2&quot;; Label label = createLabel(labelId, oldTitle); RequestLabelDto dto = createRequestLabelDto(updateTitle); given(labelRepository.findById(labelId)).willReturn(Optional.of(label)); //when label.update(dto); //then assertThat(label.getTitle()) .isNotEqualTo(oldTitle) .isEqualTo(updateTitle); then(labelRepository).should().findById(labelId);} 에러 코드Wanted but not invoked:labelRepository.findById(1L);-&amp;gt; atteam20.issuetracker.service.LabelServiceTest.givenLabelInfo_whenUpdatingLabel_thenUpdatedLabel(LabelServiceTest.java:20)Actually, there were zero interactions with this mock. 에러 문구 에러 원인 : Mockito 2.+ 새로 추가된 스터빙의 관한 이유로, 사용되지 않은 메서드가 given또는 then에 존재 하는 경우 발생한다. 업데이트 하는 로직이 label 안에 존재하긴 하나 given 에서 생성한 label 을 가지고 바로 update 를 실행하면서, labelRepository 를 거치지 않아 에러가 발생 하였다. 테스트 하는 로직이 시나리오에 맞지 않아 발생하거라 생각하면 조금 더 쉽게 원인을 알 수 있다. 위에 에러에 관한 Bdeldung 글 @DisplayName(&quot;레이블 정보를 입력하면, 해당 레이블을 수정한다.&quot;)@Testvoid givenLabelInfo_whenUpdatingLabel_thenUpdatedLabel() throws Exception { //given Long labelId = 1L; String oldTitle = &quot;labelTitle1&quot;; String updateTitle = &quot;labelTitle2&quot;; Label label = createLabel(labelId, oldTitle); RequestLabelDto dto = createRequestLabelDto(updateTitle); given(labelRepository.findById(labelId)).willReturn(Optional.of(label)); //when labelRepository.findById(labelId).orElseThrow(() -&amp;gt; { throw new IllegalArgumentException(&quot;존재하지 않는 Label 입니다.&quot;); }).update(dto); //then assertThat(label.getTitle()) .isNotEqualTo(oldTitle) .isEqualTo(updateTitle); then(labelRepository).should().findById(labelId);} 수정한 코드 : labelRepository 에서 labelId에 해당하는 Label 을 찾아서 Update 로직을 수행하여, findById() 메서드를 사용하게 되서 에러가 해결되었다.REFERENCEMockito DocsJUnit 5 User GuideAssertJ Docs" }, { "title": "(일일회고)22.07.14", "url": "/posts/(%EC%9D%BC%EC%9D%BC%ED%9A%8C%EA%B3%A0)22.07.14/", "categories": "일일회고", "tags": "일일회고", "date": "2022-07-14 23:11:00 +0900", "snippet": "👨‍💻오늘 한일 코테 대비 문제 풀이 자꾸 보다보니 풀리긴 한다 ㅠㅠ issue-tracker 프로젝트 4일차 토큰 구별은 매우 쉽게 해결 issue 생성 API는 JPA 매핑 문제로 조금 애를 먹고있다. 😆좋았던 점 알고리즘 문제를 하나 이상 해결해서 기분이 좋았다. 매우 쉬운 문제였지만, 그래도 점차 나아지고 있는거 같아 의지가 생긴다. issue-tracker 프로젝트를 진행하면서, 많은걸 배우고 있는거 같다. 사실 공부한 내용을 정리해야하는데 시간이 부족하다.(핑계..) 🥺아쉬운 점 어제 회고 작성을 못했다. 새로운 강의를 듣고있는데, 내가 모르는게 아직도 너무 많다.👨‍💻내일 할 일 issue-tracker 프로젝트 5일차 Entity 매핑 다시 생각해보기 " }, { "title": "(일일회고)22.07.12", "url": "/posts/(%EC%9D%BC%EC%9D%BC%ED%9A%8C%EA%B3%A0)22.07.12/", "categories": "일일회고", "tags": "일일회고", "date": "2022-07-12 23:56:00 +0900", "snippet": "👨‍💻오늘 한일 JPA 기본편 강의 복습 고급 매핑까지 코드스쿼드 코테 대비 1일차 문제 풀이 issue-tracker 프로젝트 2일차😆좋았던 점 오늘은 사실 여러모로 아쉬운점이 많은 날이다.🥺아쉬운 점 issue-tracker 프로젝트를 진행하면서, 기능 구현을 하나씩 할때마다 크고, 작은 문제가 자꾸 발생하여 예상보다 프로젝트 진도가 많이 느려 아쉽다. 코드스쿼드를 수료했지만, 프로젝트를 하면서 아직 내가 많이 부족하다는걸 많이 느끼게된다. 코드스쿼드 코테 대비가 시작되어 1일차 문제를 풀었으나, 두 문제중에 두개다 시간안에 해결하지 못했다. 조금은 충격이였다.💧👨‍💻내일 할 일 오늘 해결하지 못한 알고리즘 문제 재 도전 코테 대비 2일차 문제 풀이 issue-tracker 프로젝트 3일차 issue 생성 API 만들기 accessToken과 refreshToken을 구별하는 로직 추가 ec2에서 redis를 연결하지 못하는 이슈 해결 " }, { "title": "(일일회고)22.07.11", "url": "/posts/(%EC%9D%BC%EC%9D%BC%ED%9A%8C%EA%B3%A0)22.07.11/", "categories": "일일회고", "tags": "일일회고", "date": "2022-07-12 00:57:00 +0900", "snippet": "👨‍💻오늘 한일 JPA 기본편 강의 복습 연관관계 매핑 까지 듣기 꾸풀러 알고리즘 스터디 issue-tracker 프로젝트 1일차😆좋았던 점 이전에 코쿼에서 진행했던 마지막 프로젝트인 issue-tracker를 추가적으로 진행하기로한 첫날이다.🥺아쉬운 점 저녁에 급한 일정이 생겨 학습을 많이 진행하지 못했다.👨‍💻내일 할 일 JPA 기본편 강의 듣기 고급 매핑까지 꾸풀러 알고리즘 스터디 코드스쿼드 알고리즘 대비 첫날" }, { "title": "이진트리순회(DFS)", "url": "/posts/%EC%9D%B4%EC%A7%84-%ED%8A%B8%EB%A6%AC-%EC%88%9C%ED%9A%8C(DFS)/", "categories": "알고리즘", "tags": "알고리즘", "date": "2022-05-25 03:16:00 +0900", "snippet": "이진트리순회(DFS)전위 순회 부모노드 -&amp;gt; 왼쪽 자식 노드 -&amp;gt; 오른쪽 자식 노드 순으로 순회중위 순회 왼쪽 자식 노드 -&amp;gt; 부모 노드 -&amp;gt; 오른쪽 자식 노드 순으로 순회후위 순회 왼쪽 자식 노드 -&amp;gt; 오른쪽 자식 노드 -&amp;gt; 부모 노드 순으로 순회이진트리순회 구현class Node { int data; Node lt, rt; public Node(int value) { data = value; lt = rt = null; }}public class Main { Node root; public void dfs(Node root) { if (root == null) return; else { // System.out.println(&quot;root&quot;) 전위순회 dfs(root.lt); // System.out.println(&quot;root&quot;) 중위순회 dfs(root.rt); // System.out.println(&quot;root&quot;) 후위순회 } } public static void main(String[] args) { Main tree = new Main(); tree.root = new Node(1); tree.root.lt = new Node(2); tree.root.rt = new Node(3); tree.root.lt.lt = new Node(4); tree.root.rt.rt = new Node(5); tree.root.rt.lt = new Node(6); tree.root.rt.rt = new Node(7); tree.dfs(tree.root); }} 재귀를 활용하여 이진 트리 순회를 구현 출력 하는 위치에 따라 전위, 중위, 후위 순회에 맞는 값이 출력된다.부분집합(DFS)public class SubsetDFS { static class Main { static int n; static int[] ch; public void solution(int l) { if (l == n + 1) { String tmp = &quot;&quot;; for (int i = 1; i &amp;lt;= n; i++) { if (ch[i] == 1) { tmp += (i + &quot; &quot;); } } if (tmp.length() &amp;gt; 0) { System.out.println(tmp); } } else { ch[l] = 1; solution(l + 1); ch[l] = 0; solution(l + 1); } } public static void main(String[] args) { Main main = new Main(); n = 3; ch = new int[n + 1]; main.solution(1); } }} DFS를 활용하여, 부분집합 구하기 알고리즘 예제" } ]
